import React, { useState, useEffect, useRef } from 'react';
import { io, Socket } from 'socket.io-client';
import OBSWebSocket from 'obs-websocket-js';
import Hls from 'hls.js';

// OBS WebSocket types
interface ObsStatus {
    stream: any;
    record: any;
    currentScene: any;
    scenes: any[];
}

declare global {
    interface Window {
        webkitAudioContext?: typeof AudioContext;
    }
}

interface Status {
    text: string;
    active: boolean;
}



interface LiveProps {
    streamKey: string;
}

const Live: React.FC<LiveProps> = ({ streamKey }) => {
    // Environment variables centralizadas
    const NGINX_IP = '192.168.101.63';
    const SOCKET_URL = `http://${NGINX_IP}:5000`;
    const STREAM_KEY = streamKey;
    const HLS_BASE_URL = `http://${NGINX_IP}:8080`; // NGINX sirve HLS en puerto 8080

    // Video references
    const rtmpVideoRef = useRef<HTMLVideoElement | null>(null);
    const localVideoRef = useRef<HTMLVideoElement | null>(null);

    // Socket reference
    const socketRef = useRef<Socket | null>(null);

    // HLS reference
    const rtmpHlsRef = useRef<Hls | null>(null);
    
    // ‚úÖ NUEVO: Control de inicializaci√≥n HLS para evitar parpadeo
    const hlsInitializingRef = useRef<boolean>(false);
    const hlsReadyRef = useRef<boolean>(false);

    // OBS WebSocket reference
    const obsWsRef = useRef<OBSWebSocket | null>(null);

    // Intervals
    const forcedMuteIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
    const heartbeatIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);

    // State
    const [isRtmpAvailable, setIsRtmpAvailable] = useState<boolean>(false);
    const [currentVideoIndex, setCurrentVideoIndex] = useState<number>(0);
    const [videosList, setVideosList] = useState<string[]>([]);
    const [audioEnabled, setAudioEnabled] = useState<boolean>(true);
    const [showingRtmp, setShowingRtmp] = useState<boolean>(false);
    const [userHasInteracted, setUserHasInteracted] = useState<boolean>(true);
    const [rtmpStatus, setRtmpStatus] = useState<Status>({ text: 'Desconectado', active: false });
    const [localStatus, setLocalStatus] = useState<Status>({ text: 'Activo', active: true });
    const [isWaitingForStream, setIsWaitingForStream] = useState<boolean>(false);
    const [waitingMessage, setWaitingMessage] = useState<string>('Esperando stream...');

    // ‚úÖ NUEVO: Estados para monitoreo RTMP
    const [rtmpStatusMonitor, setRtmpStatusMonitor] = useState<string>('UNKNOWN');
    const [lastRtmpCheck, setLastRtmpCheck] = useState<Date | null>(null);
    
    // ‚úÖ NUEVO: Refs para control de monitoreo
    const rtmpStatusIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
    const isMonitoringRtmpRef = useRef<boolean>(false);

    // Playback health monitoring refs
    const playbackHealthIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
    const lastTimeRef = useRef<number>(0);
    const stagnantCounterRef = useRef<number>(0);
    const lastStallRecoveryRef = useRef<number>(0);
    const lastBufferLogRef = useRef<number>(0);

    // ‚úÖ NUEVO: Funci√≥n para consultar estado RTMP
    const checkRtmpStatus = async () => {
        try {
            const response = await fetch(`${SOCKET_URL}/api/stream/rtmp-status/${STREAM_KEY}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'include'
            });

            if (response.ok) {
                const data = await response.json();
                console.log('üìä Estado RTMP consultado:', data);
                
                setLastRtmpCheck(new Date());
                
                if (data.rtmpActive) {
                    setRtmpStatusMonitor('ACTIVE');
                    if (!isRtmpAvailable) {
                        console.log('üîÑ RTMP detectado como activo, actualizando estado');
                        handleRtmpStatusChange(true);
                    }
                } else {
                    setRtmpStatusMonitor('INACTIVE');
                    if (isRtmpAvailable) {
                        console.log('üîÑ RTMP detectado como inactivo, actualizando estado');
                        handleRtmpStatusChange(false);
                    }
                }
                
                return data;
            }
        } catch (error) {
            console.error('‚ùå Error consultando estado RTMP:', error);
            setRtmpStatusMonitor('ERROR');
        }
        return null;
    };

    // ‚úÖ NUEVO: Iniciar monitoreo peri√≥dico de RTMP
    const startRtmpMonitoring = () => {
        if (isMonitoringRtmpRef.current) {
            console.log('‚ö†Ô∏è Monitoreo RTMP ya est√° activo');
            return;
        }

        console.log('üîç Iniciando monitoreo peri√≥dico de estado RTMP');
        isMonitoringRtmpRef.current = true;

        // Verificar inmediatamente
        checkRtmpStatus();

        // Verificar cada 10 segundos
        rtmpStatusIntervalRef.current = setInterval(checkRtmpStatus, 10000);
    };

    // ‚úÖ NUEVO: Detener monitoreo RTMP
    const stopRtmpMonitoring = () => {
        if (rtmpStatusIntervalRef.current) {
            clearInterval(rtmpStatusIntervalRef.current);
            rtmpStatusIntervalRef.current = null;
        }
        isMonitoringRtmpRef.current = false;
        console.log('üõë Monitoreo RTMP detenido');
    };

    // ================== HLS CLEANUP HELPER ==================
    const cleanupHLS = () => {
        console.log('üßπ Limpiando estado HLS completamente');
        stopPlaybackHealthMonitor();
        
        // ‚úÖ NUEVO: Resetear flags de control
        hlsInitializingRef.current = false;
        hlsReadyRef.current = false;

        if (rtmpHlsRef.current) {
            try {
                rtmpHlsRef.current.destroy();
            } catch (e) {
                console.log('‚ö†Ô∏è Error destruyendo HLS:', e);
            }
            rtmpHlsRef.current = null;
        }

        // Reset video element
        const rtmpVideo = rtmpVideoRef.current;
        if (rtmpVideo) {
            rtmpVideo.pause();
            rtmpVideo.src = '';
            rtmpVideo.load();
        }
    };

    // ================== PLAYBACK HEALTH MONITOR ==================
    const startPlaybackHealthMonitor = () => {
        stopPlaybackHealthMonitor();
        lastTimeRef.current = 0;
        stagnantCounterRef.current = 0;
        playbackHealthIntervalRef.current = setInterval(() => {
            const video = rtmpVideoRef.current;
            if (!video || !showingRtmp) return;

            const now = performance.now();
            const currentTime = video.currentTime;
            const readyState = video.readyState; // 0-4 (HAVE_NOTHING .. HAVE_ENOUGH_DATA)

            // Detect stagnant playback (time not advancing)
            if (!video.paused && Math.abs(currentTime - lastTimeRef.current) < 0.15) {
                stagnantCounterRef.current += 1;
            } else {
                stagnantCounterRef.current = 0;
            }
            lastTimeRef.current = currentTime;

            // Compute buffer ahead
            let bufferAhead = 0;
            try {
                const buf = video.buffered;
                for (let i = 0; i < buf.length; i++) {
                    if (currentTime >= buf.start(i) && currentTime <= buf.end(i)) {
                        bufferAhead = buf.end(i) - currentTime;
                        break;
                    }
                }
            } catch { }

            // Live edge distance
            let liveEdgeGap = 0;
            if (video.seekable && video.seekable.length > 0) {
                const liveEdge = video.seekable.end(video.seekable.length - 1);
                liveEdgeGap = liveEdge - currentTime;
            }

            // Log occasionally (every 5s)
            if (now - lastBufferLogRef.current > 5000) {
                lastBufferLogRef.current = now;
                console.log('‚è±Ô∏è Health', { ct: currentTime.toFixed(2), bufferAhead: bufferAhead.toFixed(2), liveGap: liveEdgeGap.toFixed(2), readyState, stagnant: stagnantCounterRef.current });
            }

            const hls = rtmpHlsRef.current as any;

            // Recovery strategies - MUY AGRESIVAS para ultra-baja latencia
            const tooFarBehind = liveEdgeGap > 3; // ‚úÖ ULTRA AGRESIVO: 15s -> 3s
            const lowBuffer = bufferAhead < 0.5;   // ‚úÖ M√ÅS TOLERANTE: 0.05 -> 0.5s
            const stagnant = stagnantCounterRef.current >= 3; // ‚úÖ MUY R√ÅPIDO: 8 -> 3 segundos

            if ((tooFarBehind || (lowBuffer && !video.paused) || stagnant) && now - lastStallRecoveryRef.current > 2000) { // ‚úÖ RECUPERACI√ìN M√ÅS R√ÅPIDA: 8s -> 2s
                lastStallRecoveryRef.current = now;
                console.warn('‚ö†Ô∏è Playback degradation detected', { tooFarBehind, lowBuffer, stagnant, readyState });

                try {
                    // ‚úÖ ULTRA-AGRESIVO: Saltar al live edge m√°s frecuentemente
                    if (video.seekable && video.seekable.length > 0 && (tooFarBehind || stagnant)) {
                        const edge = video.seekable.end(video.seekable.length - 1) - 0.2; // ‚úÖ M√°s cerca del edge: 0.5s -> 0.2s
                        console.log('‚ö° Jumping to live edge for ultra-low latency', edge);
                        video.currentTime = edge;
                    }

                    // Solo intentar play si est√° pausado
                    if (video.paused) {
                        video.play().catch(() => { });
                    }

                    // ‚úÖ M√ÅS AGRESIVO: Restart load m√°s frecuentemente
                    if ((lowBuffer || stagnant) && hls && hls.startLoad) {
                        console.log('üîÑ Reiniciando carga HLS para ultra-baja latencia');
                        hls.startLoad();
                    }
                } catch (e) {
                    console.log('‚ùå Error during ultra-low latency recovery', e);
                }
            }
        }, 1000); // check every second
    };

    const stopPlaybackHealthMonitor = () => {
        if (playbackHealthIntervalRef.current) {
            clearInterval(playbackHealthIntervalRef.current);
            playbackHealthIntervalRef.current = null;
        }
    };

    // ‚úÖ HLS.js ya est√° disponible como import directo - no necesita CDN
    useEffect(() => {
        console.log('‚úÖ HLS.js cargado como m√≥dulo de Node.js:', Hls.isSupported());
    }, []);

    // Initialize component
    useEffect(() => {
        console.log('üöÄ Inicializando viewer para:', STREAM_KEY);

        // ‚úÖ NUEVO: Iniciar en estado de espera por defecto
        setIsWaitingForStream(true);
        setWaitingMessage('Conectando al stream...');

        enableAutoAudio();
        setupEventListeners();
        connectSocket();
        startHeartbeat();
        startRtmpMonitoring(); // ‚úÖ NUEVO: Iniciar monitoreo RTMP

        // ‚úÖ NUEVO: Verificaci√≥n peri√≥dica de estado para evitar pantallas negras
        const stateCheckInterval = setInterval(() => {
            if (socketRef.current?.connected && isWaitingForStream) {
                console.log('üîç Verificaci√≥n peri√≥dica de estado - Cliente esperando...');
                socketRef.current.emit('force_state_check', { streamKey: STREAM_KEY });
            }
        }, 10000); // Cada 10 segundos

        // ‚úÖ MEJORADO: Mecanismo de respaldo m√°s inteligente
        const videoRequestInterval = setInterval(() => {
            if (socketRef.current?.connected) {
                if (videosList.length === 0 && !isRtmpAvailable) {
                    console.log('üìÅ Solicitando videos (sin videos locales y sin RTMP)');
                    socketRef.current.emit('request_videos_list', { streamKey: STREAM_KEY });
                }
                
                // ‚úÖ NUEVO: Forzar verificaci√≥n si llevamos mucho tiempo esperando
                if (isWaitingForStream) {
                    console.log('ÔøΩ Forzando verificaci√≥n por tiempo de espera prolongado');
                    socketRef.current.emit('force_state_check', { streamKey: STREAM_KEY });
                }
            }
        }, 8000); // Cada 8 segundos

        return () => {
            clearInterval(videoRequestInterval);
            clearInterval(stateCheckInterval);
            stopRtmpMonitoring(); // ‚úÖ NUEVO: Detener monitoreo RTMP
            cleanup();
        };
    }, []);

    const startHeartbeat = () => {
        // Enviar heartbeat cada 30 segundos
        heartbeatIntervalRef.current = setInterval(() => {
            if (socketRef.current && socketRef.current.connected) {
                socketRef.current.emit('heartbeat');
            }
        }, 30000);
    };

    // Setup RTMP stream when HLS is available and RTMP status changes
    useEffect(() => {
        if (Hls.isSupported() && isRtmpAvailable) {
            setupRtmpStream();
        }
    }, [isRtmpAvailable]);

    // Start local video when videos list changes
    useEffect(() => {
        if (videosList.length > 0) {
            console.log('üìÅ Lista de videos actualizada, verificando si se debe iniciar reproducci√≥n');
            
            // Solo iniciar video si no estamos mostrando RTMP y no hay video reproduci√©ndose
            if (!showingRtmp && !isWaitingForStream) {
                const localVideo = localVideoRef.current;
                const needsVideo = !localVideo || 
                                 localVideo.paused || 
                                 !localVideo.src || 
                                 localVideo.src === '' ||
                                 localVideo.ended;
                
                if (needsVideo) {
                    console.log('üé¨ No hay video reproduci√©ndose, iniciando videos locales');
                    startLocalVideo();
                } else {
                    console.log('‚úÖ Ya hay video reproduci√©ndose, no interrumpiendo');
                }
            } else if (showingRtmp) {
                console.log('üì° RTMP activo, no iniciando videos locales');
            } else if (isWaitingForStream) {
                console.log('‚è≥ En pantalla de espera, no iniciando videos locales');
            }
        } else {
            console.log('‚ö†Ô∏è Lista de videos vac√≠a');
        }
    }, [videosList, showingRtmp, isWaitingForStream]);

    const enableAutoAudio = () => {
        console.log('üîä Activando audio autom√°ticamente para OBS');
        setAudioEnabled(true);
        setUserHasInteracted(true);

        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('üéµ Contexto de audio activado');
                });
            }
        } catch (error) {
            console.log('‚ö†Ô∏è No se pudo crear contexto de audio:', error);
        }
    };

    const setupEventListeners = () => {
        // Will be set up in useEffect for each video element
    };

    const connectSocket = () => {
        socketRef.current = io(SOCKET_URL, {
            transports: ['polling', 'websocket'], // Comenzar con polling, luego websocket
            forceNew: true, // Forzar nueva conexi√≥n
            timeout: 20000, // Timeout de conexi√≥n
            reconnection: true, // Habilitar reconexi√≥n autom√°tica
            reconnectionAttempts: 5, // Intentos de reconexi√≥n
            reconnectionDelay: 1000, // Delay entre intentos
            withCredentials: true // Incluir credentials
        });

        socketRef.current.on('connect', () => {
            console.log('üîå Socket conectado');
            socketRef.current?.emit('join', STREAM_KEY);
            
            // ‚úÖ NUEVO: Solicitar lista de videos inmediatamente al conectar
            setTimeout(() => {
                if (videosList.length === 0) {
                    console.log('üìÅ No hay videos cargados, solicitando lista al servidor');
                    socketRef.current?.emit('request_videos_list', { streamKey: STREAM_KEY });
                }
            }, 1000);
        });

        socketRef.current.on('connect_error', (error) => {
            console.error('‚ùå Error de conexi√≥n Socket.IO:', error);
            setIsWaitingForStream(true);
            setWaitingMessage('Error de conexi√≥n, reintentando...');
        });

        socketRef.current.on('disconnect', (reason) => {
            console.log('üîå Socket desconectado, raz√≥n:', reason);
            setIsWaitingForStream(true);
            setWaitingMessage('Conexi√≥n perdida, reintentando...');
        });

        socketRef.current.on('reconnect', (attemptNumber) => {
            console.log('üîÑ Socket reconectado en intento:', attemptNumber);
            socketRef.current?.emit('join', STREAM_KEY);
        });

        socketRef.current.on('reconnect_error', (error) => {
            console.error('‚ùå Error de reconexi√≥n:', error);
            setWaitingMessage('Error de reconexi√≥n...');
        });

        // ‚úÖ NUEVO: Escuchar cambios de estado RTMP
        socketRef.current.on('rtmp_status_change', (data: { 
            streamKey: string;
            rtmpStatus: 'ACTIVE' | 'INACTIVE' | 'STOPPED';
            rtmpAvailable: boolean;
            deviceConnected: boolean;
            timestamp: string;
            message: string;
            action: string;
            fallbackActive?: boolean;
        }) => {
            console.log('üì° Cambio de estado RTMP recibido:', data);
            
            if (data.streamKey === STREAM_KEY) {
                setRtmpStatusMonitor(data.rtmpStatus);
                
                switch (data.rtmpStatus) {
                    case 'ACTIVE':
                        console.log('‚úÖ RTMP ACTIVO:', data.message);
                        setIsWaitingForStream(false);
                        handleRtmpStatusChange(true);
                        break;
                        
                    case 'INACTIVE':
                        console.log('‚ö†Ô∏è RTMP INACTIVO:', data.message);
                        handleRtmpStatusChange(false);
                        break;
                        
                    case 'STOPPED':
                        console.log('üõë STREAM FINALIZADO:', data.message);
                        setIsWaitingForStream(true);
                        setWaitingMessage('Stream finalizado');
                        handleRtmpStatusChange(false);
                        break;
                }
            }
        });

        // ‚úÖ NUEVO: Escuchar cuando el stream est√° activo
        socketRef.current.on('streamActive', (data: { 
            streamActive: boolean; 
            deviceConnected: boolean; 
            rtmpAvailable: boolean; 
            videosList: string[] 
        }) => {
            console.log('üé¨ Stream activo recibido:', data);
            console.log('üîç Estado previo:', { isWaitingForStream, showingRtmp, isRtmpAvailable });
            
            // El stream est√° activo, ocultar pantalla de espera y mostrar contenido
            setIsWaitingForStream(false);
            console.log('‚úÖ Pantalla de espera OCULTADA por streamActive');
            
            if (data.videosList && data.videosList.length > 0) {
                setVideosList(data.videosList);
                console.log('üìÅ Videos del stream activo:', data.videosList);
                
                // ‚úÖ NUEVO: Si no hay RTMP, iniciar videos locales inmediatamente
                if (!data.rtmpAvailable) {
                    console.log('üé¨ No hay RTMP activo, iniciando videos locales inmediatamente');
                    setTimeout(() => {
                        const localVideo = localVideoRef.current;
                        if (!localVideo || localVideo.paused || !localVideo.src) {
                            startLocalVideo();
                        }
                    }, 500);
                }
            }
            
            // Manejar estado de RTMP DESPU√âS de ocultar pantalla de espera
            setTimeout(() => {
                handleRtmpStatusChange(data.rtmpAvailable, data.videosList);
            }, 100);
        });

        socketRef.current.on('deviceStatusChange', (data: { rtmpAvailable: boolean; videosList: string[] }) => {
            console.log('üì± Cambio de dispositivo RTMP:', data);
            // Solo manejar cambios de RTMP, no de stream completo
            handleRtmpStatusChange(data.rtmpAvailable, data.videosList);
        });

        socketRef.current.on('disconnect', () => {
            console.log('üîå Socket desconectado - Mostrando pantalla de espera...');
            // ‚úÖ CAMBIO: Mostrar pantalla de espera en lugar de reload inmediato
            setIsWaitingForStream(true);
            setWaitingMessage('Conexi√≥n perdida, reintentando...');
            
            // Recargar despu√©s de un tiempo si no se reconecta
            setTimeout(() => {
                if (!socketRef.current?.connected) {
                    window.location.reload();
                }
            }, 10000); // 10 segundos
        });

        // ‚úÖ NUEVO: Escuchar eventos de clientes hu√©rfanos
        socketRef.current.on('waitingForStream', (data: { streamKey: string; message: string; status: string }) => {
            console.log('‚è≥ Esperando stream recibido:', data);
            console.log('üîç Estado actual antes de waitingForStream:', { 
                isWaitingForStream, 
                showingRtmp, 
                isRtmpAvailable 
            });
            
            setIsWaitingForStream(true);
            setWaitingMessage(data.message);
            
            // ‚úÖ NUEVO: Limpiar HLS y parar videos cuando volvemos a espera
            cleanupHLS();
            setIsRtmpAvailable(false);
            setShowingRtmp(false);
            
            // Pausar video local
            const localVideo = localVideoRef.current;
            if (localVideo) {
                localVideo.pause();
                console.log('‚è∏Ô∏è Video local pausado por waitingForStream');
            }
            
            // ‚úÖ NUEVO: Solicitar videos mientras esperamos
            setTimeout(() => {
                if (socketRef.current?.connected) {
                    console.log('üìÅ Solicitando videos mientras esperamos stream');
                    socketRef.current.emit('request_videos_list', { streamKey: STREAM_KEY });
                }
            }, 2000);
            
            console.log('‚úÖ Pantalla de espera activada por waitingForStream');
        });

        // ‚úÖ NUEVO: Escuchar cuando el stream inicia
        socketRef.current.on('streamStarted', (data: { streamKey: string; message: string; action: string }) => {
            console.log('üéâ Stream iniciado:', data);
            // ‚úÖ CAMBIO: No recargar autom√°ticamente, dejar que streamActive maneje el estado
            setIsWaitingForStream(false);
            setWaitingMessage('Stream iniciado...');
        });

        // ‚úÖ NUEVO: Escuchar cuando el stream se detiene
        socketRef.current.on('streamStopped', (data: { streamKey: string; message: string; action: string }) => {
            console.log('üõë Stream detenido recibido:', data);
            console.log('üîç Estado actual:', { 
                isWaitingForStream, 
                showingRtmp, 
                isRtmpAvailable,
                videoListLength: videosList.length 
            });
            
            // ‚úÖ MEJORADO: Mostrar pantalla de espera en lugar de recargar
            setIsWaitingForStream(true);
            setWaitingMessage(data.message || 'Stream detenido, esperando reconexi√≥n...');
            
            // Limpiar todo el estado del stream
            cleanupHLS();
            setIsRtmpAvailable(false);
            setShowingRtmp(false);
            
            // ‚úÖ NUEVO: Pausar video local tambi√©n
            const localVideo = localVideoRef.current;
            if (localVideo) {
                localVideo.pause();
                console.log('‚è∏Ô∏è Video local pausado por detenci√≥n de stream');
            }
            
            console.log('‚úÖ Pantalla de espera activada por stream detenido');
        });

        // ‚úÖ NUEVO: Escuchar respuesta de lista de videos solicitada
        socketRef.current.on('videos_list_response', (data: { streamKey: string; videosList: string[] }) => {
            console.log('üìÅ Lista de videos recibida:', data);
            if (data.videosList && data.videosList.length > 0) {
                setVideosList(data.videosList);
                
                // ‚úÖ MEJORADO: Si no estamos mostrando RTMP y no hay video reproduci√©ndose, iniciar videos locales
                if (!showingRtmp && !isWaitingForStream) {
                    const localVideo = localVideoRef.current;
                    const needsToStartVideo = !localVideo || 
                                            localVideo.paused || 
                                            !localVideo.src || 
                                            localVideo.src === '';
                    
                    if (needsToStartVideo) {
                        console.log('üé¨ Iniciando videos locales con nueva lista recibida');
                        setTimeout(() => startLocalVideo(), 500);
                    } else {
                        console.log('‚úÖ Ya hay un video reproduci√©ndose, no iniciando nuevo');
                    }
                }
            }
        });

        // ‚úÖ NUEVO: Manejar forzar reproducci√≥n local
        socketRef.current.on('forceLocalPlayback', (data: { streamKey: string; videosList: string[]; reason: string }) => {
            console.log('üîÑ Forzando reproducci√≥n local:', data);
            
            if (data.streamKey === STREAM_KEY && data.videosList && data.videosList.length > 0) {
                setVideosList(data.videosList);
                setIsWaitingForStream(false);
                setShowingRtmp(false);
                setIsRtmpAvailable(false);
                
                console.log('üé¨ Forzando inicio de videos locales por:', data.reason);
                setTimeout(() => {
                    startLocalVideo();
                }, 100);
            }
        });

        // ‚úÖ NUEVO: Escuchar cuando el stream se inicia/reinicia
        socketRef.current.on('streamStarted', (data: { streamKey: string; message: string; action: string }) => {
            console.log('üéâ Stream iniciado/reiniciado recibido:', data);
            console.log('üîç Estado actual antes de streamStarted:', { 
                isWaitingForStream, 
                showingRtmp, 
                isRtmpAvailable 
            });
            
            // ‚úÖ IMPORTANTE: Solo ocultar pantalla de espera si corresponde al streamKey actual
            if (data.streamKey === STREAM_KEY) {
                setIsWaitingForStream(false);
                setWaitingMessage('Stream iniciado, conectando...');
                
                console.log('‚úÖ Pantalla de espera desactivada por stream iniciado');
                
                // ‚úÖ NUEVO: Solicitar estado actual del stream
                setTimeout(() => {
                    if (socketRef.current?.connected) {
                        console.log('üì° Solicitando estado actual del stream tras reinicio');
                        socketRef.current.emit('join', STREAM_KEY);
                    }
                }, 500);
            } else {
                console.log('‚ö†Ô∏è streamStarted para streamKey diferente, ignorando');
            }
        });

        // ‚úÖ NUEVO: Debug - Exponer funci√≥n de estado en window para debugging
        if (typeof window !== 'undefined') {
            (window as any).debugStreamState = () => {
                console.log('üîç ESTADO ACTUAL DEL STREAM:', {
                    isWaitingForStream,
                    showingRtmp,
                    isRtmpAvailable,
                    videosList: videosList.length,
                    userHasInteracted,
                    audioEnabled,
                    rtmpStatus: rtmpStatus.text,
                    localStatus: localStatus.text,
                    socketConnected: socketRef.current?.connected || false
                });
                
                const localVideo = localVideoRef.current;
                const rtmpVideo = rtmpVideoRef.current;
                
                console.log('üé¨ ESTADO DE VIDEOS:', {
                    localVideo: {
                        exists: !!localVideo,
                        src: localVideo?.src || 'none',
                        paused: localVideo?.paused,
                        muted: localVideo?.muted,
                        volume: localVideo?.volume,
                        currentTime: localVideo?.currentTime,
                        duration: localVideo?.duration
                    },
                    rtmpVideo: {
                        exists: !!rtmpVideo,
                        src: rtmpVideo?.src || 'none', 
                        paused: rtmpVideo?.paused,
                        muted: rtmpVideo?.muted,
                        volume: rtmpVideo?.volume,
                        currentTime: rtmpVideo?.currentTime
                    }
                });
            };
        }

        // ========== OBS WEBSOCKET INTEGRATION ==========
        // Registrar este cliente como cliente OBS
        socketRef.current.emit('register_obs_client', {
            streamKey: STREAM_KEY,
            clientInfo: {
                userAgent: navigator.userAgent,
                timestamp: new Date().toISOString()
            }
        });

        // Escuchar confirmaci√≥n de registro OBS
        socketRef.current.on('obs_client_registered', (data: { success: boolean; clientId: string; streamKey: string }) => {
            console.log('üì∫ Cliente OBS registrado:', data);
        });

        // Escuchar comandos OBS del servidor
        socketRef.current.on('obs_command', (data: any) => {
            console.log('üì® Comando OBS recibido:', data);
            handleObsCommand(data);
        });
    };

    // ========== OBS WEBSOCKET FUNCTIONS ==========
    let obsWS: any = null;

    // Variables para controlar el estado OBS
    const [obsConnectionStatus, setObsConnectionStatus] = useState<string>('disconnected');
    const [isObsStreaming, setIsObsStreaming] = useState<boolean>(false);
    const [currentObsScene, setCurrentObsScene] = useState<string>('');
    const [obsScenes, setObsScenes] = useState<string[]>([]);

    // Funci√≥n para manejar comandos OBS del servidor
    const handleObsCommand = async (data: any) => {
        switch (data.type) {
            case 'execute_obs_action':
                await executeObsAction(data.action, data.params);
                break;

            case 'execute_obs_action_with_response':
                await executeObsActionWithResponse(data.action, data.params, data.requestId);
                break;

            case 'request_obs_status':
                await sendCurrentObsStatus();
                break;

            case 'connect_to_obs':
                console.log(`üîó Credenciales recibidas: ${data.credentials.address}`);
                await connectToOBSWithCredentials(data.credentials.address, data.credentials.password);
                break;
        }
    };

    // Funci√≥n para conectar a OBS WebSocket
    const connectToOBSWithCredentials = async (address: string, password: string) => {
        if (obsWS) {
            await obsWS.disconnect();
        }

        updateObsStatus('Conectando...', 'connecting');

        try {
            // Usar la biblioteca obs-websocket-js importada
            obsWS = new OBSWebSocket();
            await obsWS.connect(`ws://${address}`, password);

            updateObsStatus('Conectado', 'connected');
            console.log(`‚úÖ Conectado a OBS: ${address}`);

            setupObsEvents();
            await getInitialObsStatus();

            // Notificar al servidor
            sendObsStatusToServer({
                connection_status: 'connected',
                address: address,
                timestamp: new Date().toISOString()
            });

        } catch (error: any) {
            updateObsStatus('Error de conexi√≥n', 'error');
            console.error(`‚ùå Error conectando a OBS: ${error.message}`);

            // Notificar al servidor del error
            sendObsStatusToServer({
                connection_status: 'error',
                error: error.message,
                address: address,
                timestamp: new Date().toISOString()
            });
        }
    };

    const setupObsEvents = () => {
        if (!obsWS) return;

        obsWS.on('StreamStateChanged', (data: any) => {
            console.log(`üî¥ Stream: ${data.outputState}`);
            const isStreaming = data.outputActive;
            setIsObsStreaming(isStreaming);
            sendObsStatusToServer({ 
                event: 'stream_state_changed', 
                data: data,
                isStreaming: isStreaming 
            });
        });

        obsWS.on('RecordStateChanged', (data: any) => {
            console.log(`‚ö™ Grabaci√≥n: ${data.outputState}`);
            sendObsStatusToServer({ 
                event: 'record_state_changed', 
                data: data 
            });
        });

        obsWS.on('CurrentProgramSceneChanged', (data: any) => {
            console.log(`üé¨ Escena: ${data.sceneName}`);
            setCurrentObsScene(data.sceneName);
            sendObsStatusToServer({ 
                event: 'scene_changed', 
                data: data,
                currentScene: data.sceneName 
            });
        });
    };

    const updateObsStatus = (status: string, connectionStatus: string) => {
        setObsConnectionStatus(connectionStatus);
        console.log(`üì∫ OBS Status: ${status} (${connectionStatus})`);
    };

    const sendObsStatusToServer = (status: any) => {
        if (socketRef.current) {
            socketRef.current.emit('obs_status_update', { status });
        }
    };

    // Ejecutar acci√≥n OBS con respuesta
    const executeObsActionWithResponse = async (action: string, params = {}, requestId: string) => {
        if (!obsWS) {
            const errorResponse = {
                requestId: requestId,
                success: false,
                error: 'No conectado a OBS',
                obsData: null
            };
            socketRef.current?.emit('obs_response', errorResponse);
            console.log('‚ùå No conectado a OBS');
            return;
        }

        try {
            const result = await obsWS.call(action, params);
            console.log(`‚úÖ Acci√≥n ejecutada: ${action}`);

            const successResponse = {
                requestId: requestId,
                success: true,
                error: null,
                obsData: result,
                executedAction: action,
                executedParams: params
            };
            socketRef.current?.emit('obs_response', successResponse);

            // Actualizar estado despu√©s de la acci√≥n
            if (action.includes('Stream') || action.includes('Record')) {
                setTimeout(getInitialObsStatus, 1000);
            }

        } catch (error: any) {
            console.error(`‚ùå Error ejecutando ${action}: ${error.message}`);

            const errorResponse = {
                requestId: requestId,
                success: false,
                error: error.message,
                obsData: null,
                executedAction: action,
                executedParams: params
            };
            socketRef.current?.emit('obs_response', errorResponse);
        }
    };

    // Ejecutar acci√≥n OBS simple
    const executeObsAction = async (action: string, params = {}) => {
        if (!obsWS) {
            console.log('‚ùå No conectado a OBS');
            return;
        }

        try {
            const result = await obsWS.call(action, params);
            console.log(`‚úÖ Acci√≥n ejecutada: ${action}`);

            // Actualizar estado despu√©s de la acci√≥n
            if (action.includes('Stream') || action.includes('Record')) {
                setTimeout(getInitialObsStatus, 1000);
            }

            sendObsStatusToServer({
                action_executed: action,
                result: result,
                timestamp: new Date().toISOString()
            });

        } catch (error: any) {
            console.error(`‚ùå Error ejecutando ${action}: ${error.message}`);
        }
    };

    const getInitialObsStatus = async () => {
        if (!obsWS) return;

        try {
            const [streamStatus, recordStatus, currentScene, sceneList] = await Promise.all([
                obsWS.call('GetStreamStatus'),
                obsWS.call('GetRecordStatus'),
                obsWS.call('GetCurrentProgramScene'),
                obsWS.call('GetSceneList')
            ]);

            const status = {
                stream: streamStatus,
                record: recordStatus,
                currentScene: currentScene,
                scenes: sceneList.scenes,
                isStreaming: streamStatus.outputActive,
                currentSceneName: currentScene.currentProgramSceneName
            };

            setIsObsStreaming(streamStatus.outputActive);
            setCurrentObsScene(currentScene.currentProgramSceneName);
            setObsScenes(sceneList.scenes.map((scene: any) => scene.sceneName));

            sendObsStatusToServer(status);

        } catch (error: any) {
            console.error(`‚ùå Error obteniendo estado: ${error.message}`);
        }
    };

    const sendCurrentObsStatus = async () => {
        await getInitialObsStatus();
    };

    // ‚úÖ NUEVO: Funci√≥n cr√≠tica para manejar cambios en el estado RTMP
    const handleRtmpStatusChange = (rtmpAvailable: boolean, videosList?: string[]) => {
        console.log('üì° Manejando cambio de estado RTMP:', { rtmpAvailable, videosListLength: videosList?.length || 0 });
        console.log('üîç Estado antes del cambio:', { 
            isRtmpAvailable, 
            showingRtmp, 
            isWaitingForStream,
            hlsInitializing: hlsInitializingRef.current,
            hlsReady: hlsReadyRef.current
        });

        const wasAvailable = isRtmpAvailable;
        setIsRtmpAvailable(rtmpAvailable);

        if (videosList && videosList.length > 0) {
            setVideosList(videosList);
            console.log('üìÅ Videos actualizados:', videosList.length);
        }

        // ‚úÖ IMPORTANTE: Solo proceder si NO estamos en pantalla de espera
        if (isWaitingForStream) {
            console.log('‚è≥ En pantalla de espera, ignorando cambios RTMP hasta que stream est√© activo');
            return;
        }

        if (rtmpAvailable && !wasAvailable) {
            console.log('üì° Dispositivo RTMP conectado - PREPARANDO CAMBIO DIRECTO');
            console.log('üîá FORZANDO MUTEO PERMANENTE de videos locales por nueva conexi√≥n RTMP');

            forceLocalVideoMute();
            startForcedMuteMonitor();

            setRtmpStatus({ text: 'Conectando...', active: true });

            // ‚úÖ SIMPLIFICADO: Configurar HLS y cambiar directamente
            if (Hls.isSupported()) {
                console.log('üöÄ Configurando stream RTMP inmediatamente');
                setupRtmpStream();
            }

        } else if (rtmpAvailable) {
            console.log('üì° RTMP ya disponible - FORZANDO CAMBIO INMEDIATO');
            setRtmpStatus({ text: 'Conectado', active: true });
            forceLocalVideoMute();
            startForcedMuteMonitor();
            console.log('üîá Videos locales FORZOSAMENTE muteados - RTMP activo');
            
            // ‚úÖ CAMBIO DIRECTO sin esperar
            if (!showingRtmp) {
                console.log('üîÑ CAMBIANDO A RTMP INMEDIATAMENTE');
                setShowingRtmp(true);
                
                // Pausar video local inmediatamente
                const localVideo = localVideoRef.current;
                if (localVideo) {
                    localVideo.pause();
                    forceLocalVideoMute();
                }
                
                // Configurar HLS si no existe
                if (Hls.isSupported() && !hlsReadyRef.current) {
                    setupRtmpStream();
                }
                
                startPlaybackHealthMonitor();
                console.log('‚úÖ CAMBIO A RTMP COMPLETADO');
            }

        } else {
            // ‚úÖ MEJORADO: Verificar realmente si HLS est√° disponible antes de desconectar
            console.log('üîç Verificando si RTMP realmente no est√° disponible...');
            
            const streamUrl = `${HLS_BASE_URL}/hls/${STREAM_KEY}.m3u8`;
            fetch(streamUrl, { method: 'HEAD' })
                .then(response => {
                    if (response.ok) {
                        console.log('‚úÖ HLS a√∫n disponible, ignorando desconexi√≥n falsa');
                        // HLS a√∫n est√° disponible, ignorar esta desconexi√≥n
                        setIsRtmpAvailable(true); // Revertir el cambio
                        setRtmpStatus({ text: 'Conectado (verificado)', active: true });
                        return;
                    }
                    throw new Error('HLS not available');
                })
                .catch(() => {
                    // Dispositivo RTMP realmente desconectado - volver a videos locales
                    console.log('üîä Dispositivo RTMP realmente desconectado - volviendo a videos locales');
                    cleanupHLS();
                    stopForcedMuteMonitor();
                    setRtmpStatus({ text: 'Desconectado', active: false });
                    
                    // ‚úÖ IMPORTANTE: Solo cambiar a videos locales si el stream sigue activo
                    if (!isWaitingForStream) {
                        setTimeout(() => {
                            // ‚úÖ NUEVO: Asegurar que hay videos disponibles antes de cambiar
                            if (videosList && videosList.length > 0) {
                                console.log('üé¨ Cambiando a videos locales tras desconexi√≥n RTMP');
                                switchToLocal();
                            } else {
                                console.log('‚ö†Ô∏è No hay videos locales disponibles, solicitando al servidor');
                                if (socketRef.current?.connected) {
                                    socketRef.current.emit('request_videos_list', { streamKey: STREAM_KEY });
                                }
                            }
                        }, 1000);
                    }
                });
        }
    };

    const forceLocalVideoMute = () => {
        const localVideo = localVideoRef.current;
        if (localVideo) {
            localVideo.muted = true;
            localVideo.volume = 0;
            console.log('üîá MUTEO FORZADO aplicado a video local (muted=true, volume=0)');
        }
    };

    const startForcedMuteMonitor = () => {
        stopForcedMuteMonitor();

        console.log('üîç Iniciando monitor de muteo forzado para videos locales');
        forcedMuteIntervalRef.current = setInterval(() => {
            const localVideo = localVideoRef.current;
            const rtmpVideo = rtmpVideoRef.current;

            if (isRtmpAvailable && localVideo) {
                if (!localVideo.muted || localVideo.volume > 0) {
                    console.log('‚ö†Ô∏è DETECTADO: Video local intent√≥ activar audio durante RTMP - FORZANDO MUTEO');
                    forceLocalVideoMute();
                }

                if (showingRtmp && rtmpVideo && rtmpVideo.muted && audioEnabled) {
                    console.log('üîä Reactivando audio RTMP que fue muteado accidentalmente');
                    rtmpVideo.muted = false;
                }
            }
        }, 500);
    };

    const stopForcedMuteMonitor = () => {
        if (forcedMuteIntervalRef.current) {
            clearInterval(forcedMuteIntervalRef.current);
            forcedMuteIntervalRef.current = null;
            console.log('üõë Monitor de muteo forzado detenido');
        }
    };

    const waitForHLSAvailability = (callback: () => void) => {
        const maxWait = 25000; // 25 segundos m√°ximo
        const checkInterval = 500; // Verificar cada 500ms
        let elapsed = 0;
        let lastError = '';
        let consecutiveSuccesses = 0;

        const checkHLS = async () => {
            try {
                const hlsUrl = `${HLS_BASE_URL}/hls/${STREAM_KEY}.m3u8`;
                console.log(`üîç Verificando HLS: ${hlsUrl}`);
                
                // ‚úÖ CORREGIDO: Petici√≥n simplificada sin headers problem√°ticas
                const response = await fetch(hlsUrl, {
                    method: 'GET',
                    cache: 'no-store' // Usar cache standard en lugar de headers personalizadas
                });
                
                if (response.ok) {
                    const content = await response.text();
                    const segmentMatches = content.match(/\.ts/g);
                    const hasValidPlaylist = content.includes('#EXTM3U');
                    const segmentCount = segmentMatches ? segmentMatches.length : 0;
                    
                    console.log(`üìä HLS Check: Playlist v√°lida: ${hasValidPlaylist}, Segmentos: ${segmentCount}`);
                    
                    if (hasValidPlaylist && segmentCount >= 2) {
                        consecutiveSuccesses++;
                        console.log(`‚úÖ HLS v√°lido (${consecutiveSuccesses}/2) con ${segmentCount} segmentos`);
                        
                        if (consecutiveSuccesses >= 2) {
                            console.log(`üéâ HLS confirmado disponible con ${segmentCount} segmentos`);
                            callback();
                            return;
                        } else {
                            lastError = `Esperando confirmaci√≥n (${consecutiveSuccesses}/2)`;
                        }
                    } else {
                        consecutiveSuccesses = 0;
                        lastError = `Playlist: ${hasValidPlaylist ? 'OK' : 'INVALID'}, Segmentos: ${segmentCount} (necesita >=2)`;
                    }
                } else {
                    consecutiveSuccesses = 0;
                    lastError = `HTTP ${response.status}: ${response.statusText}`;
                }
            } catch (error: any) {
                consecutiveSuccesses = 0;
                lastError = error.message || 'Error de red';
            }

            elapsed += checkInterval;
            if (elapsed < maxWait) {
                // Loguear cada 2 segundos
                if (elapsed % 2000 === 0) {
                    console.log(`‚è≥ Esperando HLS (${elapsed}ms): ${lastError}`);
                }
                setTimeout(checkHLS, checkInterval);
            } else {
                console.warn(`‚è∞ Timeout esperando HLS despu√©s de ${elapsed}ms. √öltimo error: ${lastError}`);
                console.log('üîÑ Continuando con callback de todas formas...');
                callback();
            }
        };

        setTimeout(checkHLS, checkInterval);
    };

    const setupRtmpStream = () => {
        const streamUrl = `${HLS_BASE_URL}/hls/${STREAM_KEY}.m3u8`;
        const rtmpVideo = rtmpVideoRef.current;

        console.log('üé¨ Configurando stream RTMP optimizado:', streamUrl);
        console.log('üì∫ Elemento de video RTMP:', rtmpVideo ? 'Disponible' : 'No disponible');
        console.log('üîß HLS.js:', Hls.isSupported() ? 'Soportado' : 'No soportado');

        if (!rtmpVideo || !Hls.isSupported()) {
            console.error('‚ùå No se puede configurar RTMP: elementos faltantes');
            return;
        }

        // ‚úÖ NUEVO: Evitar inicializaci√≥n m√∫ltiple simult√°nea
        if (hlsInitializingRef.current) {
            console.log('‚ö†Ô∏è HLS ya se est√° inicializando, esperando...');
            return;
        }

        // ‚úÖ NUEVO: Si ya tenemos una instancia funcionando, no recrear
        if (rtmpHlsRef.current && hlsReadyRef.current) {
            console.log('‚úÖ HLS ya est√° configurado y funcionando');
            return;
        }

        hlsInitializingRef.current = true;
        hlsReadyRef.current = false;

        // Limpiar instancia anterior solo si es necesario
        if (rtmpHlsRef.current) {
            console.log('üßπ Limpiando instancia HLS anterior');
            try {
                rtmpHlsRef.current.destroy();
            } catch (error) {
                console.warn('‚ö†Ô∏è Error limpiando HLS anterior:', error);
            }
            rtmpHlsRef.current = null;
        }

        // ‚úÖ MEJORADO: Resetear video sin operaciones innecesarias
        if (rtmpVideo.src !== '') {
            rtmpVideo.removeAttribute('src');
            rtmpVideo.load();
        }

        if (Hls.isSupported()) {
            console.log('üöÄ Inicializando HLS.js con configuraci√≥n optimizada');
            
            // ‚úÖ OPTIMIZADO: Configuraci√≥n ultra-baja latencia para NGINX HLS
            const hlsConfig = {
                debug: false,
                enableWorker: true,
                lowLatencyMode: true,
                backBufferLength: 10,          // ‚úÖ Buffer menor: 90s -> 10s
                maxBufferLength: 4,            // ‚úÖ Buffer m√°ximo menor: 30s -> 4s
                maxMaxBufferLength: 8,         // ‚úÖ Buffer absoluto menor: 60s -> 8s
                startLevel: -1,
                capLevelToPlayerSize: true,
                testBandwidth: false,
                abrEwmaDefaultEstimate: 5000000,
                manifestLoadingTimeOut: 5000,  // ‚úÖ Timeout menor: 10s -> 5s
                manifestLoadingMaxRetry: 2,    // ‚úÖ Menos reintentos: 3 -> 2
                manifestLoadingRetryDelay: 250, // ‚úÖ Retry m√°s r√°pido: 500ms -> 250ms
                levelLoadingTimeOut: 5000,     // ‚úÖ Timeout menor: 10s -> 5s
                levelLoadingMaxRetry: 3,       // ‚úÖ Menos reintentos: 4 -> 3
                levelLoadingRetryDelay: 250,   // ‚úÖ Retry m√°s r√°pido: 500ms -> 250ms
                fragLoadingTimeOut: 8000,      // ‚úÖ Timeout menor: 20s -> 8s
                fragLoadingMaxRetry: 4,        // ‚úÖ Menos reintentos: 6 -> 4
                fragLoadingRetryDelay: 250,    // ‚úÖ Retry m√°s r√°pido: 500ms -> 250ms
                liveSyncDurationCount: 1,      // ‚úÖ Ultra agresivo: 3 -> 1 (solo 1 fragmento de sync)
                liveMaxLatencyDurationCount: 3, // ‚úÖ M√°s agresivo: 10 -> 3
                liveDurationInfinity: false,
                maxLiveSyncPlaybackRate: 2.0,  // ‚úÖ Recuperaci√≥n m√°s r√°pida: 1.5 -> 2.0
                minAutoBitrate: 0,             // ‚úÖ Permitir cualquier bitrate para velocidad
                maxSeekHole: 2                 // ‚úÖ Saltar agujeros peque√±os r√°pidamente
            };
            
            const hls = new Hls(hlsConfig);
            rtmpHlsRef.current = hls;

            // ‚úÖ MEJORADO: Event listeners optimizados
            hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                console.log('üì∫ HLS media attached correctamente');
            });

            hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
                console.log('üìã HLS manifest parseado:', data.levels.length, 'niveles de calidad');
                hlsInitializingRef.current = false;
                hlsReadyRef.current = true;
                
                // Intentar reproducir autom√°ticamente
                if (userHasInteracted && isRtmpAvailable) {
                    rtmpVideo.play().then(() => {
                        console.log('‚ñ∂Ô∏è HLS reproduciendo autom√°ticamente');
                        startPlaybackHealthMonitor();
                    }).catch(error => {
                        console.warn('‚ö†Ô∏è No se pudo reproducir autom√°ticamente:', error);
                    });
                }
            });

            hls.on(Hls.Events.LEVEL_SWITCHED, (event, data) => {
                console.log(`üîÑ HLS cambi√≥ a nivel de calidad: ${data.level}`);
            });

            hls.on(Hls.Events.FRAG_LOADED, () => {
                // Fragment cargado exitosamente
                if (hlsInitializingRef.current) {
                    hlsInitializingRef.current = false;
                    hlsReadyRef.current = true;
                }
            });

            hls.on(Hls.Events.ERROR, (event, data) => {
                console.error('‚ùå Error HLS:', data.type, data.details);
                
                if (data.fatal) {
                    hlsInitializingRef.current = false;
                    hlsReadyRef.current = false;
                    
                    switch (data.type) {
                        case Hls.ErrorTypes.NETWORK_ERROR:
                            console.log('üîÑ Error de red, intentando recuperar...');
                            hls.startLoad();
                            break;
                        case Hls.ErrorTypes.MEDIA_ERROR:
                            console.log('üîÑ Error de media, intentando recuperar...');
                            hls.recoverMediaError();
                            break;
                        default:
                            console.log('üí• Error fatal, recreando HLS...');
                            setTimeout(() => {
                                if (isRtmpAvailable) {
                                    setupRtmpStream();
                                }
                            }, 2000);
                            break;
                    }
                }
            });

            // Configurar y cargar stream
            hls.loadSource(streamUrl);
            hls.attachMedia(rtmpVideo);

        } else if (rtmpVideo.canPlayType('application/vnd.apple.mpegurl')) {
            console.log('üçé Usando reproducci√≥n HLS nativa (Safari)');
            rtmpVideo.src = streamUrl;
            hlsInitializingRef.current = false;
            hlsReadyRef.current = true;
        } else {
            console.error('‚ùå HLS no soportado en este navegador');
            hlsInitializingRef.current = false;
        }
    };


    const startLocalVideo = () => {
        if (videosList.length === 0) {
            console.log('‚ö†Ô∏è No hay videos disponibles para startLocalVideo');
            // ‚úÖ NUEVO: Solicitar videos si no hay ninguno
            if (socketRef.current && socketRef.current.connected) {
                console.log('üìÅ Solicitando lista de videos al servidor');
                socketRef.current.emit('request_videos_list', { streamKey: STREAM_KEY });
            }
            return;
        }

        // ‚úÖ NUEVO: Verificar si ya hay un video reproduci√©ndose antes de cambiar
        const localVideo = localVideoRef.current;
        if (localVideo && !localVideo.paused && localVideo.src && !localVideo.ended && localVideo.src !== '') {
            console.log('‚úÖ Ya hay un video reproduci√©ndose, verificando si es v√°lido...');
            
            // Verificar si el src actual est√° en la lista de videos v√°lidos
            const currentUrl = localVideo.src;
            const isValidVideo = videosList.some(video => currentUrl.includes(video) || video.includes(currentUrl.split('/').pop() || ''));
            
            if (isValidVideo) {
                console.log('‚úÖ Video actual es v√°lido, no interrumpiendo');
                return;
            } else {
                console.log('‚ö†Ô∏è Video actual no es v√°lido, cambiando a uno nuevo');
            }
        }

        // ‚úÖ NUEVO: Asegurar que no estamos en estado de espera
        if (isWaitingForStream) {
            console.log('‚ö†Ô∏è A√∫n en estado de espera, no iniciando video local');
            return;
        }

        const randomIndex = Math.floor(Math.random() * videosList.length);
        loadLocalVideo(randomIndex);
        console.log('üé¨ Rotaci√≥n autom√°tica por tiempo DESHABILITADA - videos cambiar√°n solo al terminar');
    };

    const loadLocalVideo = (index: number) => {
        if (videosList.length === 0) return;

        index = index % videosList.length;
        setCurrentVideoIndex(index);

        const videoUrl = videosList[index];
        const videoName = videoUrl.split('/').pop();
        const localVideo = localVideoRef.current;

        if (!localVideo) return;

        console.log('üé≤ Reproduciendo video aleatorio [' + (index + 1) + '/' + videosList.length + ']:', videoName);

        localVideo.src = videoUrl;
        localVideo.load();

        if (isRtmpAvailable) {
            localVideo.muted = true;
            localVideo.volume = 0;
            console.log('üîá Video local cargado con MUTEO FORZADO (RTMP activo)');
        } else if (userHasInteracted) {
            localVideo.muted = false;
            localVideo.volume = 1;
        } else {
            localVideo.muted = true;
            localVideo.volume = 0;
        }

        localVideo.play().then(() => {
            if (!showingRtmp && audioEnabled && userHasInteracted) {
                localVideo.muted = false;
                console.log('üîä Audio local activado autom√°ticamente');
            }
        }).catch(error => {
            console.error('Error al reproducir video:', error);
            localVideo.muted = true;
            localVideo.play().catch(e => {
                console.error('Error al reproducir video muteado:', e);
            });
        });

        setLocalStatus({
            text: `Video ${index + 1}/${videosList.length} - ${videoName}`,
            active: true
        });
    };

    const rotateLocalVideo = () => {
        let nextIndex;
        if (videosList.length <= 1) {
            nextIndex = 0;
        } else {
            do {
                nextIndex = Math.floor(Math.random() * videosList.length);
            } while (nextIndex === currentVideoIndex);
        }
        console.log('üîÑ Rotando a nuevo video aleatorio desde √≠ndice', currentVideoIndex, 'a', nextIndex);
        loadLocalVideo(nextIndex);
    };

    const switchToRtmp = () => {
        console.log('üîÑ switchToRtmp llamado - verificando condiciones...');
        console.log('üìä Estado actual:', {
            isRtmpAvailable,
            showingRtmp,
            hasHlsInstance: !!rtmpHlsRef.current,
            hlsReady: hlsReadyRef.current,
            videoElement: !!rtmpVideoRef.current
        });

        if (!isRtmpAvailable) {
            console.warn('‚ö†Ô∏è switchToRtmp llamado pero isRtmpAvailable es false');
            return;
        }
        
        // ‚úÖ MEJORADO: Avoid redundant switches causing flicker
        if (showingRtmp && hlsReadyRef.current) {
            console.log('‚úÖ Ya mostrando RTMP con HLS listo, verificando estado del video...');
            
            const rtmpVideo = rtmpVideoRef.current;
            if (rtmpVideo && rtmpVideo.paused) {
                console.log('üîÑ Video RTMP pausado, reactivando...');
                rtmpVideo.play().catch(error => {
                    console.error('‚ùå Error reactivando video RTMP:', error);
                });
            }
            
            // Ensure monitor running
            if (!playbackHealthIntervalRef.current) {
                startPlaybackHealthMonitor();
            }
            return;
        }

        console.log('üîÑ Cambiando a RTMP');
        setShowingRtmp(true);

        const rtmpVideo = rtmpVideoRef.current;
        const localVideo = localVideoRef.current;

        // Pausar y mutear video local inmediatamente
        if (localVideo) {
            localVideo.pause();
            forceLocalVideoMute();
        }

        if (userHasInteracted) {
            setAudioEnabled(true);
        }

        // ‚úÖ MEJORADO: Manejar reproducci√≥n del video m√°s eficientemente
        if (rtmpVideo) {
            console.log('üì∫ Configurando video RTMP para reproducci√≥n...');
            
            // ‚úÖ NUEVO: Verificar que tenemos HLS listo antes de proceder
            if (!hlsReadyRef.current) {
                console.warn('‚ö†Ô∏è HLS no est√° listo, configurando...');
                setupRtmpStream();
                
                // ‚úÖ MEJORADO: Esperar a que HLS est√© listo antes de reproducir
                const checkHlsReady = () => {
                    if (hlsReadyRef.current && rtmpVideo.paused) {
                        rtmpVideo.play().catch(error => {
                            console.error('‚ùå Error reproduciendo despu√©s de HLS ready:', error);
                        });
                    } else if (!hlsReadyRef.current) {
                        setTimeout(checkHlsReady, 200);
                    }
                };
                setTimeout(checkHlsReady, 500);
                
            } else {
                // Ya tenemos HLS listo, solo reproducir si es necesario
                if (rtmpVideo.paused) {
                    console.log('üé¨ Reproduciendo video RTMP...');
                    rtmpVideo.play().catch(error => {
                        console.error('‚ùå Error reproduciendo video RTMP:', error);
                    });
                }
            }

            // ‚úÖ NUEVO: RTMP siempre con audio activo
            rtmpVideo.muted = false;
            rtmpVideo.volume = 1;
            console.log('üîä Audio RTMP SIEMPRE activo (muted=false, volume=1)');
        }

        console.log('üîä Audio RTMP: configurado autom√°ticamente');
        console.log('üîá Audio local: FORZOSAMENTE MUTEADO por conexi√≥n RTMP activa');
        startPlaybackHealthMonitor();
    };

    const switchToLocal = () => {
        console.log('üîÑ Cambiando a videos locales');
        setShowingRtmp(false);
        stopPlaybackHealthMonitor();

        const rtmpVideo = rtmpVideoRef.current;
        const localVideo = localVideoRef.current;

        // ‚úÖ CAMBIO: Restaurar audio local cuando no hay RTMP pero el stream sigue activo
        if (audioEnabled && userHasInteracted && localVideo) {
            localVideo.muted = false;
            localVideo.volume = 1;
            console.log('üîä Audio local: reactivado tras desconexi√≥n RTMP (muted=false, volume=1)');
        } else if (localVideo) {
            localVideo.muted = true;
            localVideo.volume = 0;
            console.log('üîá Audio local: mantenido muteado por configuraci√≥n');
        }

        // ‚úÖ NUEVO: RTMP nunca se mutea, mantener audio activo
        if (rtmpVideo) {
            rtmpVideo.muted = false;
            rtmpVideo.volume = 1;
            console.log('üîä Audio RTMP mantenido activo incluso en modo local');
        }

        // ‚úÖ MEJORADO: Asegurar que los videos locales se reproduzcan correctamente
        if (videosList.length > 0) {
            // Si no hay video cargado o est√° vac√≠o, cargar uno nuevo
            if (!localVideo || !localVideo.src || localVideo.src === '') {
                console.log('üìΩÔ∏è No hay video local cargado, iniciando reproducci√≥n de videos');
                startLocalVideo();
            } else {
                // Si hay video pero est√° pausado, reproducirlo
                if (localVideo.paused) {
                    console.log('‚ñ∂Ô∏è Reanudando video local pausado');
                    localVideo.play().catch(error => {
                        console.error('Error al reproducir video local pausado, cargando nuevo video:', error);
                        // Si falla la reproducci√≥n, cargar un video diferente
                        rotateLocalVideo();
                    });
                } else {
                    console.log('‚úÖ Video local ya se est√° reproduciendo');
                }
            }
        } else {
            console.warn('‚ö†Ô∏è No hay videos disponibles para reproducir');
        }
    };

    const toggleAudio = () => {
        const newAudioEnabled = !audioEnabled;
        setAudioEnabled(newAudioEnabled);

        const rtmpVideo = rtmpVideoRef.current;
        const localVideo = localVideoRef.current;

        if (showingRtmp && rtmpVideo) {
            // ‚úÖ NUEVO: RTMP nunca se mutea, siempre activo
            rtmpVideo.muted = false;
            rtmpVideo.volume = 1;
            forceLocalVideoMute();
            console.log('üîä Audio RTMP: SIEMPRE activo (nunca se mutea)');
            console.log('üîá Audio local: FORZOSAMENTE muteado por conexi√≥n RTMP activa');
        } else if (localVideo) {
            localVideo.muted = !newAudioEnabled;
            localVideo.volume = newAudioEnabled ? 1 : 0;
            // ‚úÖ NUEVO: RTMP nunca se mutea
            if (rtmpVideo) {
                rtmpVideo.muted = false;
                rtmpVideo.volume = 1;
            }
            console.log(`üîä Audio local: ${newAudioEnabled ? 'activado' : 'desactivado'}`);
        }

        console.log(`üéµ Audio general: ${newAudioEnabled ? 'ON' : 'OFF'}`);

        if (showingRtmp || isRtmpAvailable) {
            console.log('üì° POL√çTICA ACTIVA: Videos locales permanecen FORZOSAMENTE muteados mientras hay conexi√≥n RTMP');
        }

        if (newAudioEnabled) {
            console.log('üéôÔ∏è Audio activado - Listo para captura en OBS');
        }
    };

    const switchVideo = () => {
        if (showingRtmp && videosList.length > 0) {
            switchToLocal();
        } else if (!showingRtmp && isRtmpAvailable) {
            switchToRtmp();
        } else if (!showingRtmp) {
            rotateLocalVideo();
        }
    };

    const cleanup = () => {
        console.log('üßπ Cleanup general del componente');

        if (socketRef.current) {
            socketRef.current.disconnect();
        }

        if (heartbeatIntervalRef.current) {
            clearInterval(heartbeatIntervalRef.current);
            heartbeatIntervalRef.current = null;
        }

        cleanupHLS();
        stopForcedMuteMonitor();
    };    // Event handlers for video elements
    // Event handlers for video elements
    const handleRtmpCanPlay = () => {
        console.log('üì∫ RTMP Video can play - estado:', {
            isRtmpAvailable,
            showingRtmp,
            paused: rtmpVideoRef.current?.paused,
            readyState: rtmpVideoRef.current?.readyState,
            currentTime: rtmpVideoRef.current?.currentTime
        });
        
        // ‚úÖ CORREGIDO: Cambio inmediato y directo cuando RTMP puede reproducir
        if (isRtmpAvailable && !showingRtmp) {
            console.log('üîÑ RTMP puede reproducir - CAMBIANDO INMEDIATAMENTE');
            setShowingRtmp(true);
            
            // Pausar video local inmediatamente
            const localVideo = localVideoRef.current;
            if (localVideo) {
                localVideo.pause();
                forceLocalVideoMute();
                console.log('‚è∏Ô∏è Video local pausado por cambio a RTMP');
            }
            
            const rtmpVideo = rtmpVideoRef.current;
            if (rtmpVideo) {
                // ‚úÖ NUEVO: RTMP siempre con audio activo
                rtmpVideo.muted = false;
                rtmpVideo.volume = 1;
                console.log('üîä Audio RTMP SIEMPRE activo (muted=false, volume=1)');
                
                if (rtmpVideo.paused) {
                    rtmpVideo.play().catch(error => {
                        console.error('‚ùå Error reproduciendo RTMP en canPlay:', error);
                    });
                }
            }
            
            startPlaybackHealthMonitor();
            console.log('‚úÖ CAMBIO A RTMP COMPLETADO');
            
        } else if (isRtmpAvailable && showingRtmp) {
            console.log('‚úÖ Ya mostrando RTMP, verificando reproducci√≥n y audio');
            const rtmpVideo = rtmpVideoRef.current;
            if (rtmpVideo) {
                // ‚úÖ NUEVO: RTMP siempre con audio activo
                rtmpVideo.muted = false;
                rtmpVideo.volume = 1;
                console.log('üîä Audio RTMP mantenido activo');
                
                if (rtmpVideo.paused) {
                    console.log('üîÑ Video pausado, reactivando');
                    rtmpVideo.play().catch(error => {
                        console.error('‚ùå Error reactivando desde canplay:', error);
                    });
                }
            }
        }
    };

    const handleLocalEnded = () => {
        console.log('üé¨ Video terminado, cambiando a uno aleatorio');
        rotateLocalVideo();
    };

    const handleLocalError = (e: React.SyntheticEvent<HTMLVideoElement, Event>) => {
        const videoEl = e.target as HTMLVideoElement;
        const error = videoEl?.error;
        console.error('Error en video local:', error);
        const errorCode = error ? error.code : 'unknown';
        console.log('üîç C√≥digo de error:', errorCode);

        if (errorCode === 3 || errorCode === 4) {
            console.log('‚ùå Error cr√≠tico, cambiando video en 3 segundos...');
            setTimeout(() => {
                rotateLocalVideo();
            }, 3000);
        } else {
            console.log('‚ö†Ô∏è Error menor, intentando continuar reproducci√≥n...');
            setTimeout(() => {
                const localVideo = localVideoRef.current;
                if (localVideo && localVideo.paused && !showingRtmp) {
                    localVideo.play().catch(() => {
                        console.log('üîÑ No se pudo reanudar, cambiando video...');
                        rotateLocalVideo();
                    });
                }
            }, 1000);
        }
    };

    const handleLocalLoadedData = () => {
        if (isRtmpAvailable) {
            forceLocalVideoMute();
            console.log('üîá Muteo forzado aplicado al cargar datos (RTMP activo)');
        }

        const localVideo = localVideoRef.current;
        if (localVideo && !showingRtmp) {
            // ‚úÖ MEJORADO: Verificar si el video est√° pausado antes de intentar reproducir
            if (localVideo.paused) {
                console.log('‚ñ∂Ô∏è Video local cargado y pausado, iniciando reproducci√≥n');
                localVideo.play().catch(error => {
                    console.error('Error al reproducir video despu√©s de cargar:', error);
                    // Si falla la reproducci√≥n, intentar con otro video
                    setTimeout(() => {
                        rotateLocalVideo();
                    }, 1000);
                });
            } else {
                console.log('‚úÖ Video local cargado y ya se est√° reproduciendo');
            }
        }
    };

    const handleLocalVolumeChange = () => {
        const localVideo = localVideoRef.current;
        if (isRtmpAvailable && localVideo && (!localVideo.muted || localVideo.volume > 0)) {
            console.log('‚ö†Ô∏è DETECTADO: Cambio de volumen en video local durante RTMP - FORZANDO MUTEO');
            forceLocalVideoMute();
        }
    };

    return (
        <div className="relative w-screen h-screen bg-black text-white bg-back overflow-hidden">
            {/* ‚úÖ NUEVO: Pantalla de espera */}
            {isWaitingForStream && (
                <div className="absolute inset-0 bg-gradient-to-br from-gray-900 to-gray-800 flex flex-col justify-center items-center z-50">
                    <div className="text-4xl font-light mb-8 text-center text-white">
                        Esperando Stream
                    </div>
                    
                    {/* Spinner animado */}
                    <div className="w-20 h-20 border-4 border-gray-400 border-l-blue-500 rounded-full animate-spin mb-8"></div>
                    
                    <div className="text-xl text-gray-300 text-center opacity-80">
                        {waitingMessage}
                        <span className="inline-flex ml-1">
                            <span className="animate-pulse">.</span>
                            <span className="animate-pulse delay-150">.</span>
                            <span className="animate-pulse delay-300">.</span>
                        </span>
                        <br />
                        <br />
                        <span className="text-sm">Stream ID: {STREAM_KEY.substring(0, 8)}...</span>
                    </div>
                </div>
            )}

            {/* ‚úÖ NUEVO: Indicador de estado RTMP */}
            <div className="fixed top-4 right-4 z-40">
                <div className={`px-3 py-2 rounded-lg text-sm font-medium transition-all duration-300 ${
                    rtmpStatusMonitor === 'ACTIVE' 
                        ? 'bg-green-500 text-white shadow-lg' 
                        : rtmpStatusMonitor === 'INACTIVE'
                        ? 'bg-orange-500 text-white shadow-lg'
                        : rtmpStatusMonitor === 'STOPPED'
                        ? 'bg-red-500 text-white shadow-lg'
                        : rtmpStatusMonitor === 'ERROR'
                        ? 'bg-red-600 text-white shadow-lg animate-pulse'
                        : 'bg-gray-500 text-white shadow-lg'
                }`}>
                    <div className="flex items-center gap-2">
                        <div className={`w-2 h-2 rounded-full ${
                            rtmpStatusMonitor === 'ACTIVE' ? 'bg-white animate-pulse' : 'bg-white/70'
                        }`}></div>
                        <span>
                            RTMP: {rtmpStatusMonitor === 'UNKNOWN' ? 'Conectando...' : rtmpStatusMonitor}
                        </span>
                        {lastRtmpCheck && (
                            <span className="text-xs opacity-75">
                                {lastRtmpCheck.toLocaleTimeString()}
                            </span>
                        )}
                    </div>
                </div>
            </div>

            {/* Video Container */}
            <div className="relative w-full h-full bg-black">
                {/* RTMP Video */}
                <video
                    ref={rtmpVideoRef}
                    className={`absolute inset-0 w-full h-full object-contain bg-black transition-opacity duration-700 z-10 ${showingRtmp ? 'opacity-100' : 'opacity-0'
                        }`}
                    autoPlay
                    playsInline
                    onCanPlay={handleRtmpCanPlay}
                    onPlay={() => console.log('üì∫ RTMP Video started playing')}
                    onPause={() => console.log('‚è∏Ô∏è RTMP Video paused')}
                    onWaiting={() => console.log('‚è≥ RTMP Video waiting for data')}
                    onLoadStart={() => console.log('üì• RTMP Video load started')}
                    onLoadedData={() => console.log('‚úÖ RTMP Video data loaded')}
                    onError={(e) => {
                        const video = e.target as HTMLVideoElement;
                        console.error('‚ùå RTMP Video error:', video.error);
                    }}
                />

                {/* Local Video */}
                {!showingRtmp && !isWaitingForStream && (
                    <h1 className='fixed text-white text-4xl p-10 z-50 translate-y-1/2 w-screen text-center text-shadow-md text-shadow-black '>
                        Restableciendo conexi√≥n...
                    </h1>
                )}
                <video
                    ref={localVideoRef}
                    className={`absolute inset-0 w-full h-full object-contain bg-black transition-opacity duration-700 z-5 ${!showingRtmp ? 'opacity-100' : 'opacity-0'
                        }`}
                    autoPlay
                    muted
                    playsInline
                    onEnded={handleLocalEnded}
                    onError={handleLocalError}
                    onLoadedData={handleLocalLoadedData}
                    onVolumeChange={handleLocalVolumeChange}
                >
                </video>
            </div>

            {/* Controls */}
            <div className="fixed hidden top-5 right-5 bg-black bg-opacity-80 p-5 rounded-lg z-50">
                {/* RTMP Status */}
                {/*         <div className={`mb-3 p-3 rounded-md ${
          rtmpStatus.active ? 'bg-green-500 bg-opacity-30' : 'bg-red-500 bg-opacity-30'
        }`}>
          <div className="text-sm">
            RTMP: <span className="font-semibold">{rtmpStatus.text}</span>
          </div>
        </div>
        
        <div className={`mb-3 p-3 rounded-md ${
          localStatus.active ? 'bg-green-500 bg-opacity-30' : 'bg-red-500 bg-opacity-30'
        }`}>
          <div className="text-sm">
            Video Local: <span className="font-semibold">{localStatus.text}</span>
          </div>
        </div> */}

                {/* Control Buttons */}
                {/*         <div className="flex flex-col gap-2">
          <button
            onClick={toggleAudio}
            className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded-md text-sm font-medium transition-colors duration-200 flex items-center justify-center gap-2"
          >
            üîä Audio
          </button>
          
          <button
            onClick={switchVideo}
            className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded-md text-sm font-medium transition-colors duration-200 flex items-center justify-center gap-2"
          >
            üîÑ Cambiar
          </button>
        </div> */}
            </div>

            {/* Debug Info */}
            <div className="fixed hidden bottom-5 left-5 bg-black bg-opacity-80 p-3 rounded-lg z-50 text-xs">
                <div>Stream Key: {STREAM_KEY}</div>
                <div>Socket: {SOCKET_URL}</div>
                <div>Videos: {videosList.length}</div>
                <div>RTMP: {isRtmpAvailable ? 'Disponible' : 'No disponible'}</div>
                <div>Mostrando: {showingRtmp ? 'RTMP' : 'Local'}</div>
                <div>Audio: {audioEnabled ? 'ON' : 'OFF'}</div>
            </div>
        </div>
    );
};

export default Live;